#pragma region Programming Theory
// Програмування 
//  - процес створення ПЗ.
// Програмування складається з:
//  1. Аналіз задачі
//  2. Проєктування програмного коду
//  3. Написання коду
//  4. Пошук помилок
//  5. Оновлення та підтримка ПЗ
// Парадигма програмування
//  - стиль, підхід та набір прийомів до розробки ПЗ.
// Процедурне програмування
//  - парадигма програмування, яка вимагає виконання алгоритмичної декомпозиції.
// Алгоритмична декомпозиція
//  - розбиття задачі на малі алгоритми, які називаються процедурами або функціями.
// Структурне програмування
//  - різновид процедурного програмування, в якому ми об'єднуємо дані в структури та передаємо структури функціям на обробку.
// ООП - об'єктно-орієнтоване програмування
//  - підхід (парадигма) до програмування, який будується на об'єктній декомпозиції.
// Об'єктна декомпозиція 
//  - визначення сутностей в програмі, їх характеристики та способи їх взаємодії між собою.
// Мета ООП: 
//  Абстракція - концентрація тільки на найважливішому і відкидання всього не суттєвого.
// Три принципи ООП:
//  1. Інкапсуляція
//      - об'єднання даних і способів їх обробки, при цьому приховуємо внутрішню реалізацію від решти програми та надаємо інтерфейс для
// взаємодії з цією внутрішнею реалізацією.
// Приклад з життя: 
//      Мікрохвильовка
//          - внутрішня реалізація роботи прихована
//          - кнопки, ричажкі і екран це інтерфейс для взаємодії з внутрішньої реалізацією.
// Приклад з C++:
//      Клас string
//          - внутрішня реалізація
//              - динамічний масив символів (char)
//              - виділення та звільнення пам'яті приховано (абстракція)
//          - інтерфейс
//              - набір методів для роботи з рядком (substr, replace тощо)
//              - перевантажені оператори (порівняння, +)
//  2. Спадкування (розширення)
//      - принцип який дозволяє створювати нові класи на основі існуючих.
//      - принцип взаємодії об'єктів is-a (сутність А є підтипом сутності Б).
// Дві причини використання спадкування:
//  1) Уникнення дублювання коду (DRY принцип)
//      - класи-спадкоємці автоматично отримують всіх членів батьківського класу
//  2) Абстракція в рамках ієрархії
//      - визначення базової реалізації класів і абстракція від конкретної реалізації в клієнтському коді.
// Приклад з життя:
//  - базовий клас Їжа (БЖВ, нутрієнти, мікроелементи)
//      - похідні класи фрукти, овочі, консерви, напівфабрикати тощо
// Прикладний приклад:
//  - клас Character - базовий клас в відеоігрі (хп, ходьба)
//      - Scout, Bomber, Medic, Cannoneer - похідні класи конкретних юнітів, які розширюють базову логіку (власний вид атаки)
// Приклад з С++:
//  - клас exception (метод what, поле message)
//      - bad_cast, logic_error, runtime_error тощо - похідні класи
//  3. Поліморфізм
//      - принцип, який вимагає виконати різну реалізацію однієї задачі для різних даних через один інтерфейс.
//      - один інтерфейс - багато реалізацій.
// Види поліморфізму:
// 1) статичний - визначення конкретної реалізації відбувається на етапі компіляції
//      - перевантаження функцій
//          - створення функцій з однаковим іменем але різним набором параметрів
//      - перевантаження операторів
//          - визначення логіки роботи операторів для користувацьких типів
//      - перевантаження методів
//          - створення методів з однаквим іменем але різним набором параметрів
//      - шаблони функцій
//          - створення основи для автоматичної генерації функції компілятором для потрібних параметрів
//      - шаблони класів
//          - створення основи для автоматичної генерації класів компілятором для потрібних типів полів або параметрів методів.
// 2) динамічний - визначення конкретної реалізації відбувається на етапі виконання
//      - реалізується за допомогою перевизначення віртуальних методів базового класу в класах нащадках.
//      - покажчик (або посилання) на базовий клас і його метод - єдиний інтерфейс
//      - перевизначення методу в класах нащадках - багато реалізацій
//      - динамічність заключається в тому, що конкретна реалізація визначається на етапі виконання
// Віртуальні функції (або методи)
//  - функція базового класу, яку можна перевизначити в похідному класі.
//  - створюється за допомогою ключового слова virtual
// Чисто віртуальні функції
//  - це віртуальна функція, що не має власної реалізації.
//  - наявність такої функції в класі перетворює клас на абстрактний
// Абстрактні класи
//  - це класи, що не можуть мати власних екземплярів (об'єктів)
//  - створюються за допомогою чисто віртуальних функцій
// Інтерфейси
//  - контракт, який зобов'язуються виконати всі класи, що реалізують функціональність цього інтерфейсу
//  - в С++ інтерфейси реалізуються як класи, що містять тільки чисто віртуальні функції
// Структури даних
//  - це різні способи зберігання та отримання доступу до даних в програмі.
// Масиви
//  - набір елементів одного типу, які зберігаються послідовно в пам'яті
//  - в C++ реалізується через покажчик на нульовий елемент.
//  - перевага: швидкий доступ до елементу по індексу
//      - формула: (адреса нульового елементу) + (розмір елементу) * (індекс)
//  - недолік: зміна розміру вимагає перевиділення пам'яті та копіювання елементів
// Список (List)
//  - набір елементів (вузлів), що містять значення та покажчик на наступний елемент.
//  - існують двозв'язні списки
//      - кожен елемент містить покажчик на наступний та попередній елемент.
//  - перевага: зміна розміру вимагає лише переназначення покажчиків без копіювання
//  - недолік: доступ до елементу за індексом вимагає перебору всіх елементів до цього індексу
// Черга
//  - структура даних, яка надає доступ до даних за принципом FIFO
//  - FIFO - first in, first out
// Різновиди черги 
//  - кільцева черга - елемент одразу повертається в кінець черги
//  - черга з пріоритетами - елементи з більшим пріоритетом раніше виходять з черги
// Стек
//  - структура даних, яка надає доступ до даних за принципом LIFO
//  - LIFO - last in, first out
//  - приклади: стек виклику функцій, історія дій (Ctrl + Z)
// Композиція
//  - вид взаємодії між об'єктами has-a.
//  - сильне володіння
//  - один об'єкт складається з інших
//  - цикл життя об'єктів міцно пов'язаний
//      - головний об'єкт створюється разом з внутрішніми об'єктами
//      - внутрішні об'єкти знищуються разом з головним об'єктом
// Приклад:
//  - людина і її органи
//      - органи створюються разом з людиною
//      - органи знищуються разом з людиною
// Приклад з C++:
//  - клас string
//      - об'єкт класу string не може існувати без покажчика char*
// Прикладний приклад:
//  - об'єкт гравця (Player)
//      - містить посилання на свої компоненти ігрового об'єкту
// Агрегація
//  - вид взаємодії між об'єктами has-a.
//  - слабке володіння об'єктом
//  - один об'єкт містить в собі інший, але не складається з нього
//  - цикл життя об'єктів не залежить один від одного
//      - головний об'єкт і внутрішній можуть створюватись окремо
//      - головний об'єкт і внутрішній знищуються окремо
// Приклад:
//  - Група - Студенти
// Прикладний приклад:
//  - Клас Group
//  - Клас User

// Класи, об'єкти
//  - клас
//      - шаблон для створення об'єктів, що поєднує дані (поля) та поведінку (методи).
//      - визначає тип користувацького об'єкта.
//  - об'єкт
//      - екземпляр класу, конкретна сутність у пам'яті з власними значеннями полів.

// Конструктор, деструктор
//  - конструктор
//      - спеціальний метод, що викликається автоматично при створенні об'єкта.
//      - ініціалізує поля; може бути перевантаженим, з параметрами за замовчуванням або делегуючим.
//      - ім'я = імені класу; немає типу повернення.
//  - деструктор
//      - спеціальний метод, що викликається автоматично при знищенні об'єкта.
//      - звільняє ресурси (пам'ять, файли тощо); ім'я = ~ім'я_класу.
//      - не приймає параметрів, не перевантажується.

// Потоки
//  - механізм вводу/виводу даних (iostream).
//  - cin  - потік вводу (std::istream).
//  - cout - потік виводу (std::ostream).
//  - cerr - потік помилок (не буферизований).
//  - файли: ifstream (ввід), ofstream (вивід), fstream (ввід/вивід).

// Покажчик this
//  - неявний покажчик у нестатичних методах класу, що вказує на поточний об'єкт.
//  - дозволяє доступ до полів/методів: this->field.
//  - потрібен для розрізнення локальних параметрів та полів.

// Перетворення типів в C++
//  - неявне (автоматичне): int -> double.
//  - явне:
//      - C-style: (int)float_var.
//      - static_cast<T>(expr)   - компіляційний час, без перевірки.
//      - dynamic_cast<T>(ptr)  - RTTI, для поліморфних класів, nullptr при невдачі.
//      - const_cast<T>(expr)   - зняття/додавання const/volatile.
//      - reinterpret_cast<T>(expr) - побітове, небезпечне.

// Константні методи
//  - методи, позначені const після декларації: void func() const;
//  - обіцяють не змінювати стан об'єкта (окрім mutable полів).
//  - дозволяють виклик на const об'єктах/посиланнях.

// Винятки (class exception)
//  - механізм обробки помилок runtime.
//  - throw expr; - генерує виняток.
//  - try { ... } catch(Type e) { ... } - обробка.
//  - std::exception - базовий клас; похідні: bad_alloc, runtime_error тощо.
//  - noexcept - специфікатор, що функція не кидає винятків.

// Перевантаження операторів
//  - визначення поведінки операторів (+, -, ==, << тощо) для користувацьких типів.
//  - як член класу: Return operator+(const Type&);
//  - як friend: friend Return operator<<(ostream&, const Type&);
//  - не можна: ::, ., ?:, sizeof, typeid.

// Семантика переміщення
//  - оптимізація: передача ресурсів без копіювання (C++11).
//  - конструктор переміщення: Class(Class&& other) noexcept;
//  - оператор присвоєння переміщення: Class& operator=(Class&& other) noexcept;
//  - std::move(obj) - приводить до rvalue.

// Семантика копіювання
//  - копіювання ресурсів.
//  - конструктор копіювання: Class(const Class& other);
//  - оператор присвоєння: Class& operator=(const Class& other);
//  - правило трьох/п'яти: якщо потрібен один - потрібні всі (плюс move для п'яти).

// Розумні покажчики
//  - автоматичне керування пам'яттю (RAII).
//  - unique_ptr<T> - унікальне володіння, не копіюється, переміщується.
//  - shared_ptr<T> - спільне володіння, лічильник посилань.
//  - weak_ptr<T>  - слабке посилання на shared_ptr, без володіння (цикли).

// STL
//  - Standard Template Library: контейнери, алгоритми, ітератори.
//  - контейнери: vector, list, deque, set, map, unordered_map тощо.
//  - алгоритми: sort, find, transform ( <algorithm> ).
//  - ітератори: begin()/end(), reverse_iterator.

// Дружні функції
//  - friend void func(Class&); - доступ до private/protected членів.
//  - friend class Other; - весь клас має доступ.
//  - порушує інкапсуляцію, використовувати обережно.

// Статичні члени класу
//  - static дані/методи: належать класу, не об'єкту.
//  - static int count; - одна копія для всіх об'єктів.
//  - static void func(); - виклик Class::func(), без this.
//  - ініціалізація поза класом (якщо не constexpr).

// explicit конструктор
//  - explicit Class(T param); - забороняє неявне перетворення.
//  - запобігає помилкам: Class obj = 5; (без explicit - дозволено).

// Системи контролю версій
//  - інструменти відстеження змін коду.
//  - Git - розподілена: commit, branch, merge, remote (GitHub/GitLab).
//  - SVN - централізована.
//  - основні команди Git: init, add, commit, push, pull, clone.

// Шаблони класів
//  - узагальнене програмування: template <typename T> class Vector { T* data; ... };
//  - інстанціювання: Vector<int> v; - компілятор генерує код.
//  - спеціалізація: template <> class Vector<bool> { ... };
//  - параметри: typename/class, int, template<template>.

// Компілятор
//  - програма, що компілює код.
// Компіляція
//  - це попередній переклад коду мовою програмування на машинний код.
// Інтерпретатор
//  - програма, що інтерпретує код.
// Інтерпретація
//  - послідовний переклад інструкцій на машинний код і їх виконання.
//  - виконання кожної інструкції відбувається одразу після перекладу
//  - не відбувається попереднього перекладу всієї програми на машинний код.
// Лексеми
//  - найменшою неділимою одиницею мови програмування, яку може розрізнити компілятор
// Лексеми поділяються на:
//  - ключові слова (int, float, if, while тощо)
//  - оператори (+ - / . -> тощо)
//      - операнд - те над чим оператор проводить операцію
//  - літерали (значення, що вказані в коді)
//  - ідентифікатори (імена змінних, функцій, класів, структур тощо)
//      - латинські літери
//      - цифри (але не першим символом)
//      - нижнє підкреслення (_)
//  - розділові знаки ({})
// Змінна
//  - це іменована область пам'яті, що зберігає дані певного типу і може змінювати ці дані
// протягом виконання програми.
// Константа 
//  - це іменована область пам'яті, що зберігає дані певного типу і НЕ може змінювати ці дані 
// протягом виконання програми.
// Тип даних
//  - характеристика даних, яка визначає 
//      1) діапазон значень, що можуть зберігатись
//      2) оператори доступні для роботи з цими даними
// Умовні конструкції
//  - конструкція мови програмування яка дозволяє виконувати різні дії в залежності від
// деякої умови. 
//  - if-elseif-else, switch, ?:
// Циклічні конструкції
//  - конструкція мови програмування яка дозволяє виконувати деякі дії певну кількість разів
// в залежності від умови.
//  - while, do-while, for, for(each)
// Функції 
//  - іменований набір інструкцій, який можна викликати та перевикористовувати в програмі.
// Лямбда-функція
//  - це спеціальна анонімна функція, яка не має імені і використовується "на місці".
// Препроцесор
//  - програма, що обробляє код перед компіляцією та виконує директиви.
// Директиви препроцесора
//  - спеціальні команди, які виконує препроцесор.
// Приклад:
//  - define
//  - include
//  - pragma
//      - once
//      - region
// Кодування символів
//  - базовий тип char використовує 1 байт (8 біт) - 2^8 комбінацій 0 та 1 - 256 (0-255)
// 0000.0000
//  - ASCII використовує 7 біт 2^7 - 128 символів (0-127)
//  - розширена таблиця ASCII використовує 8 біт 2^8 - 256 символів
//      - має декілька версій 
//          - windows 1251 - кирилиця
//          - windowd 1252 - центрально та східно єврпоейські латинські символи
//  - Unicode
//      - UTF-8 використовує 1 байт - 256 символів
//      - UTF-16 використовує 2 байти - 16 біт - 2^16 = 65.536 символів
//      - UTF-32 використовує 4 байти - 32 біти - 2^32 = 4.294.967.286 символів
// Покажчики
//  - це спеціальна змінна, що зберігає адресу в оперативній пам'яті.
// Посилання
//  - це друге ім'я (псевдонім) для змінної.
// Способи передачі параметрів у функцію:
//  1) за значенням
//      - функція працює з копією
//  2) за адресою
//      - функція працює з копією покажчика, через який має доступ до оригіналу
//  3) за посиланням
//      - функція працює з оригінальною змінною

#pragma endregion
